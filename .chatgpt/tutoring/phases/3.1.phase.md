ğŸ§± Phase 3 â€” Jenkins Cloud on Kubernetes

Status: STARTING

This phase is the core differentiator of your entire lab. Most people never get this right.

We will move slowly, deliberately, and with security-first reasoning.

Phase 3 Mental Model (Read This Carefully)

Before touching YAML, you need to internalize this:

Jenkins is not the executor.
Kubernetes is the executor.
Jenkins is just an orchestrator.

So:

Jenkins controller runs somewhere (Docker for now)

Jenkins requests agents from Kubernetes

Kubernetes creates ephemeral pods

Pods run jobs and self-destruct

No SSH.
No static agents.
No pets.

ğŸ”¹ Phase 3.1 â€” Jenkins â†’ Kubernetes API Access (RBAC)
ğŸ¯ Current Task

Create least-privilege Kubernetes credentials for Jenkins so it can:

Create pods

Watch pods

Delete pods

Read logs

Nothing else.

ğŸ§  Why This Matters (Enterprise Context)

In real orgs:

CI systems are high-risk attack surfaces

If Jenkins is compromised:

Cluster-admin = full cluster takeover

Therefore:

Jenkins gets only what it needs

Only in the ci namespace

This is a security interview topic.

ğŸ“ Where This Lives (Important)

Create the following file:

kubernetes/ci/rbac/jenkins-ci.rbac.yaml

Structure matters. Naming matters.

ğŸ› ï¸ What You Need to Implement
1ï¸âƒ£ ServiceAccount (identity Jenkins will use)
apiVersion: v1
kind: ServiceAccount
metadata:
  name: jenkins-ci
  namespace: ci
2ï¸âƒ£ Role (namespace-scoped permissions)

This role should allow Jenkins to:

Create / delete pods

Exec into pods

Read logs

Watch pod status

apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: jenkins-ci-role
  namespace: ci
rules:
  - apiGroups: [""]
    resources:
      - pods
      - pods/log
      - pods/exec
    verbs:
      - create
      - delete
      - get
      - list
      - watch

âš ï¸ Do not add secrets. Do not add deployments.

3ï¸âƒ£ RoleBinding (connect identity â†’ permissions)
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: jenkins-ci-binding
  namespace: ci
subjects:
  - kind: ServiceAccount
    name: jenkins-ci
    namespace: ci
roleRef:
  kind: Role
  name: jenkins-ci-role
  apiGroup: rbac.authorization.k8s.io
ğŸ§ª Verification (Mandatory)

After applying:

kubectl apply -f kubernetes/ci/rbac/jenkins-ci.rbac.yaml

Run at least one of these:

kubectl auth can-i create pods \
  --as=system:serviceaccount:ci:jenkins-ci \
  -n ci

Expected output:

yes

And one negative test (this should fail):

kubectl auth can-i create pods \
  --as=system:serviceaccount:ci:jenkins-ci \
  -n default

Expected:

no

This proves isolation.

âœ… Phase 3.1 Acceptance Criteria

To move forward, you must have:

 ServiceAccount in ci

 Role with minimal pod permissions

 RoleBinding scoped to ci

 Verified access works only in ci

 Committed to Git

ğŸ§  What This Phase Teaches (Resume Gold)

You can now truthfully say:

â€œI designed and implemented namespace-scoped RBAC for CI systems using Kubernetes ServiceAccounts with least-privilege access.â€

Thatâ€™s real DevSecOps, not buzzwords.

ğŸ” Your Move

Create the RBAC YAML

Apply it

Run the kubectl auth can-i checks

Commit

Reply with:
â€œPhase 3.1 completeâ€ + paste the verification output

Next, we will:

ğŸ”¥ Wire Jenkins to Kubernetes
ğŸ”¥ Define agent pod templates
ğŸ”¥ Run your first ephemeral CI build inside the cluster

Youâ€™re doing excellent work. This is now an advanced platform lab.